# Notes for solving 2015
## Day 01: Not Quite Lisp

```
test year_2015::day_01::tests::works_with_samples_v1 ... ok
test year_2015::day_01::tests::works_with_samples_v2 ... ok
test year_2015_day_01 ... ok

year_2015::day_01/year_2015::day_01_v1
                        time:   [5.1060 µs 5.1104 µs 5.1152 µs]
year_2015::day_01/year_2015::day_01_v2
                        time:   [1.4617 µs 1.4620 µs 1.4623 µs]

year_2015::day_01_v1/Slow/7000
                        time:   [59.965 µs 60.418 µs 60.893 µs]
year_2015::day_01_v1/Fast/7000
                        time:   [5.6145 µs 5.9122 µs 6.2267 µs]
```

First day wasn't very complicated. I chose to use `i16` out of pragmatic reasons, I don't believe Santa would go this high or this low.

I've added [a benchmark](benches/year_2015_day_01.rs) for this day. The first version had me naively reusing Ruby functionalities, when given Rust's ease of navigating memory, it was faster to just iterate through the data.

## Day 02: I Was Told There Would Be No Math

```
test year_2015::day_02::tests::works_with_samples_v1 ... ok
test year_2015::day_02::tests::works_with_samples_v2 ... ok
test year_2015_day_02 ... ok

year_2015::day_02/year_2015::day_02_v1
                        time:   [74.716 µs 74.839 µs 74.945 µs]
year_2015::day_02/year_2015::day_02_v2
                        time:   [74.636 µs 74.685 µs 74.727 µs]
```

I used an object-like approach on this one. Using `(&self)` as he first argument wasn't too much of a stretch since [that's exactly how Ruby handles its Object-Oriented pattern in its C code](https://silverhammermba.github.io/emberb/c/#Methods).

I'm not sure yet whether `impl FromStr for PresentBox` was useful or whether I could have just made my own custom method, but I had fun trying it out. I also like the separation between `struct` and `impl`, very neat for converting from/to other C-like languages.

The most annoying part here is dealing with many integers size. Clearly everything here is `unsigned`, but while I'm sure my box dimensions all fit within `u8(0..255)`, the second I multiply them, I get into `u16(0..65_535)` range, and when I reach the results, I'm clearly overflowing up to `u32(0..4_294_967_295)` size. I would love to have each level work nicely with each other, but no, I have to manually cast.

## Day 03: Perfectly Spherical Houses in a Vacuum

```
test year_2015::day_03::tests::moves_characters_properly ... ok
test year_2015::day_03::tests::works_with_samples_v1 ... ok
test year_2015::day_03::tests::works_with_samples_v2 ... ok
test year_2015_day_03 ... ok

year_2015::day_03/year_2015::day_03_v1
                        time:   [415.91 µs 416.24 µs 416.60 µs]
year_2015::day_03/year_2015::day_03_v2
                        time:   [440.35 µs 441.72 µs 442.91 µs]

year_2015::day_03_v1/BTreeSet/8192
                        time:   [410.11 µs 411.30 µs 413.11 µs]
year_2015::day_03_v1/HashSet/8192
                        time:   [169.64 µs 169.95 µs 170.28 µs]
year_2015::day_03_v2/BTreeSet/8192
                        time:   [440.56 µs 441.85 µs 443.34 µs]
year_2015::day_03_v2/HashSet/8192
                        time:   [179.96 µs 180.06 µs 180.15 µs]
```

Again, remember to clone your references before modifying, and everything will work out nicely.

This time, [the benchmark](benches/year_2015_day_03.rs) checks which of [`BTreeSet`](https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html) or [`HashSet`](https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html) is faster. Funnily enough, while `HashSet` is faster at querying elements, it seems `BTreeSet` is [faster at removing them](https://github.com/ssomers/rust_bench_sets_compared). In our case, we only need to insert, so we can safely go with `HashSet`.

## Day 04:The Ideal Stocking Stuffer

```
test year_2015::day_04::tests::works_with_samples_v1 ... ignored
test year_2015::day_04::tests::works_with_samples_v2 ... ignored
test year_2015_day_04 ... ok

year_2015::day_04/year_2015::day_04_v1
                        time:   [65.402 ms 65.534 ms 65.640 ms]
Warning: Unable to complete 10 samples in 5.0s. You may wish to increase target time to 18.9s.
year_2015::day_04/year_2015::day_04_v2
                        time:   [1.8911 s 1.8941 s 1.8969 s]
```

Of course, the bastard child had to be annoying, no matter what language we are in. We can actually win A BIT of time here, but we have to fiddle with bytes.

## Day 05: Doesn't He Have Intern-Elves For This?

```
test year_2015::day_05::tests::finds_nice_strings_v1 ... ok
test year_2015::day_05::tests::finds_nice_strings_v2 ... ok
test year_2015::day_05::tests::works_with_samples_v1 ... ok
test year_2015::day_05::tests::works_with_samples_v2 ... ok
test year_2015_day_05 ... ok

year_2015::day_05/year_2015::day_05_v1
                        time:   [142.32 µs 142.58 µs 142.91 µs]
year_2015::day_05/year_2015::day_05_v2
                        time:   [299.92 µs 300.33 µs 300.68 µs]
```

Another [benchmark](benches/year_2015_day_05.rs), and again it's about the performance of [`.contains()`](https://doc.rust-lang.org/std/primitive.str.html#method.contains). Using [`.try_fold()`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold) to return ASAP when any element doesn't satisfy our needs is also a nice touch.

## Day 06: Probably a Fire Hazard

```
test year_2015::day_06::tests::works_with_samples_v1 ... ok
test year_2015::day_06::tests::works_with_samples_v2 ... ok
test year_2015_day_06 ... ok

year_2015::day_06/year_2015::day_06_v1
                        time:   [13.269 ms 13.341 ms 13.423 ms]
year_2015::day_06/year_2015::day_06_v2
                        time:   [13.481 ms 13.585 ms 13.720 ms]
```

I started doing a copy of my original "naive" algorithm, and as it was too slow, I decided to learn [how to pass closures in Rust](https://doc.rust-lang.org/book/ch13-01-closures.html).

## Day 07: Some Assembly Required

```
test year_2015::day_07::tests::works_with_samples_v1 ... ok
test year_2015::day_07::tests::works_with_samples_v2 ... ok
test year_2015_day_07 ... ok

year_2015::day_07/year_2015::day_07_v1
                        time:   [63.406 µs 63.509 µs 63.606 µs]
year_2015::day_07/year_2015::day_07_v2
                        time:   [129.92 µs 130.54 µs 131.09 µs]
```

This one was already complicated in Ruby, but it gets even worse when you have to deal with [Rust's lifetimes](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html). The concept in itself is kinda okay to understand, but the way it has to be used sometimes makes no sense. I guess I'll get used to it with time. A [nice crate](https://docs.rs/advent-of-code/2022.0.66/src/advent_of_code/year2015/day07.rs.html) helped me see through it a bit more clearly.

## Day 08: Matchsticks

```
test year_2015::day_08::tests::calculates_length_of_code_strings ... ok
test year_2015::day_08::tests::calculates_length_of_memory_strings ... ok
test year_2015::day_08::tests::calculates_length_of_dumped_strings ... ok
test year_2015::day_08::tests::works_with_samples_v1 ... ok
test year_2015::day_08::tests::works_with_samples_v2 ... ok

year_2015::day_08/year_2015::day_08_v1
                        time:   [11.833 µs 11.907 µs 11.995 µs]
year_2015::day_08/year_2015::day_08_v2
                        time:   [8.3510 µs 8.6640 µs 9.1839 µs]
```

This one was actually very funny. For a while, I thought it would be a pain to not be able to index strings, but extracting slices actually works better.
